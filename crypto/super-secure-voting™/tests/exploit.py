#!/usr/bin/env python3

import secrets # Note: this is a standard python library, not some secret part of the challenge.
import socket
import gmpy2

from common import *
from zkp import *

# Generate a fake zero knowledge proof by choosing c after chal is known.
class FakeDecryptionProof(DecryptionProof):
    # If rand == true, c ends up being an encryption of a uniformly random value. If rand == false
    # then it is an encryption of 0.
    def __init__(self, m, N, rand, msg1=None):
        # We don't know c yet.
        self.m = m
        self.N = N

        if msg1:
            self.msg1 = msg1
        elif rand:
            self.msg1 = secrets.randbelow(self.N**2)
        else:
            self.msg1 = pow(secrets.randbelow(self.N), self.N, self.N**2)

    def first_msg(self, witness):
        return self.msg1

    def second_msg(self, chal):
        g, s, t = gmpy2.gcdext(self.N, -chal)

        assert(g == 1)
        s = int(s)
        t = int(t)

        # Now s * self.N + t * (-chal) = 1, so
        # (self.msg1**s)**self.N * (self.msg1**t)**(-chal) == self.msg1
        msg2 = pow(self.msg1, s, self.N**2)
        self.c = pow(self.msg1, t, self.N**2)
        assert(self.consistent_first_msg(chal, msg2) == self.msg1)
        return msg2

    # Fake zkp that doesn't depend on c, and only works when chal == 0.
    def fake_transcript(self):
        chal = 0
        msg2 = self.fake_second_msg(chal)
        msg1 = pow(msg2, self.N, self.N**2)
        return (msg1, chal, msg2)

def setup_fake_zkp(choice, N):
    zero_or_one_proofs = [OrProof(
        FakeDecryptionProof(0, N, i == choice),
        FakeDecryptionProof(1, N, i == choice)) for i in range(N_CANDIDATES)]

    # ZKP for sum of votes must use product of msg1s to make its c consistent.
    prod_msg1 = 1
    for proof in zero_or_one_proofs:
        prod_msg1 = (prod_msg1 * proof.protocols[0].msg1) % N**2

    zero_or_one_proofs.append(OrProof(
        FakeDecryptionProof(0, N, False, prod_msg1),
        FakeDecryptionProof(1, N, False, prod_msg1)))

    zkp = AndProof(*zero_or_one_proofs)
    return zkp

# Make the connection transparent to the user.
def recvline(s):
    msg = s[1].readline()
    print(msg, end="")
    return msg

def sendline(s, msg):
    print(msg)
    s[0].sendall((msg + '\n').encode())

with open('data/public_key', 'r') as f:
    N = int(f.read())

election_id = secrets.randbits(128)
print(f"OSUSEC Presidential Election #{election_id}")

print("Candidates:")
for i, (name, slogan) in enumerate(candidates):
    print(f'{i}.\t{name:>16}: "{slogan}"')

print("\nEnter the number of the candidate you wish to vote for (or -1 for nobody):")
choice = int(input())

zkp = setup_fake_zkp(choice, N)
proof = zkp.prove((N_CANDIDATES + 1) * [(0, None)])

# Extract the corresponding ciphertexts that make the proof valid.
enc_vote = []
for i in range(N_CANDIDATES):
    enc_vote.append(zkp.protocols[i].protocols[0].c)

print("Ballot encrypted, submitting to trustee servers ...\n")

sockets = []
for host, port in trustee_hostports:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host, port))
    sockets.append((s, s.makefile('r')))

for s in sockets:
    assert("election ID?" in recvline(s))
    sendline(s, str(election_id))

for s in sockets:
    while "enter your vote." not in recvline(s):
        pass
    sendline(s, ", ".join([str(x) for x in enc_vote]))
    sendline(s, str(proof))

enc_votes = []
dec_vote_shares = []
for i, s in enumerate(sockets):
    assert "Tallying results..." in recvline(s)
    enc_votes.append(decode_ints(recvline(s), N_CANDIDATES))
    assert "Decryption shares:" in recvline(s)
    dec_vote_shares.append(decode_ints(recvline(s), N_CANDIDATES))

# All trustees should have the same set of encrypted votes.
for e in enc_votes:
    assert enc_votes[0] == e
enc_votes = enc_votes[0]

dec_vote_r = N_CANDIDATES * [1]
for trustee_shares in dec_vote_shares:
    for i, share in enumerate(trustee_shares):
        dec_vote_r[i] = (dec_vote_r[i] * share) % N

votes = [paillier_decrypt_m_from_r(c, r, N) for c, r in zip(enc_votes, dec_vote_r)]

print("\nElection Results:")
for (name, slogan), v in zip(candidates, votes):
    print(f"{name:>16}: {v}")
print("")

for s in sockets:
    recvline(s)
    sendline(s, ", ".join([str(r) for r in dec_vote_r]))

flag_share = []
for s in sockets:
    recvline(s)
    flag_share.append(bytes.fromhex(recvline(s)))

print(xor(*flag_share).decode())
